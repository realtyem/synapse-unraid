# syntax=docker/dockerfile:1
# Dockerfile to build our forked matrixdotorg/synapse docker images.
#
# Note that it uses features which are only available in BuildKit - see
# https://docs.docker.com/go/buildkit/ for more information.
#
# To build the image, run `docker build` command from the root of the
# synapse repository:
#
#    DOCKER_BUILDKIT=1 docker build -f docker/Dockerfile-unified .
#
# There is an optional PYTHON_VERSION build argument which sets the
# version of python to build against: for example:
#
#    DOCKER_BUILDKIT=1 docker build -f docker/Dockerfile-unified --build-arg PYTHON_VERSION=3.10 .
#

# Irritatingly, there is no blessed guide on how to distribute an application with its
# poetry-managed environment in a docker image. We have opted for
# `poetry export | pip install -r /dev/stdin`, but there are known bugs
# in `poetry export` whose fixes (scheduled for poetry 1.2) have yet to be released.
# In case we get bitten by those bugs in the future, the recommendations here might
# be useful:
#     https://github.com/python-poetry/poetry/discussions/1879#discussioncomment-216865
#     https://stackoverflow.com/questions/53835198/integrating-python-poetry-with-docker?answertab=scoredesc



ARG PYTHON_VERSION=3.9

###
### Stage 0: generate requirements.txt
###
FROM docker.io/python:${PYTHON_VERSION}-slim as requirements

# RUN --mount is specific to buildkit and is documented at
# https://github.com/moby/buildkit/blob/master/frontend/dockerfile/docs/syntax.md#build-mounts-run---mount.
# Here we use it to set up a cache for apt (and below for pip), to improve
# rebuild speeds on slow connections.
RUN \
   --mount=type=cache,target=/var/cache/apt,sharing=locked \
   --mount=type=cache,target=/var/lib/apt,sharing=locked \
    apt-get update -qq && apt-get install -yqq \
      build-essential cargo git libffi-dev libssl-dev \
    && rm -rf /var/lib/apt/lists/*

# We install poetry in its own build stage to avoid its dependencies conflicting with
# synapse's dependencies.
RUN --mount=type=cache,target=/root/.cache/pip \
  pip install --user "poetry==1.2.0"

WORKDIR /synapse

# Copy just what we need to run `poetry export`...
COPY pyproject.toml poetry.lock /synapse/


# If specified, we won't verify the hashes of dependencies.
# This is only needed if the hashes of dependencies cannot be checked for some
# reason, such as when a git repository is used directly as a dependency.
# Specifically, this is currently used during CI workflow testing.
ARG TEST_ONLY_SKIP_DEP_HASH_VERIFICATION

# If specified, we won't use the Poetry lockfile.
# Instead, we'll just install what a regular `pip install` would from PyPI.
# This is also currently used during CI workflow testing.
ARG TEST_ONLY_IGNORE_POETRY_LOCKFILE

# Export the dependencies, but only if we're actually going to use the Poetry lockfile.
# Otherwise, just create an empty requirements file so that the Dockerfile can
# proceed.
RUN if [ -z "$TEST_ONLY_IGNORE_POETRY_LOCKFILE" ]; then \
    /root/.local/bin/poetry export --extras all -o /synapse/requirements.txt ${TEST_ONLY_SKIP_DEP_HASH_VERIFICATION:+--without-hashes}; \
  else \
    touch /synapse/requirements.txt; \
  fi

###
### Stage 1: builder
###
FROM docker.io/python:${PYTHON_VERSION}-slim as builder

# install the OS build deps
RUN \
   --mount=type=cache,target=/var/cache/apt,sharing=locked \
   --mount=type=cache,target=/var/lib/apt,sharing=locked \
 apt-get update -qq && apt-get install -yqq \
    build-essential \
    libffi-dev \
    libjpeg-dev \
    libpq-dev \
    libssl-dev \
    libwebp-dev \
    libxml++2.6-dev \
    libxslt1-dev \
    openssl \
    rustc \
    zlib1g-dev \
    git \
    && rm -rf /var/lib/apt/lists/*

# To speed up rebuilds, install all of the dependencies before we copy over
# the whole synapse project, so that this layer in the Docker cache can be
# used while you develop on the source
#
# This is aiming at installing the `[tool.poetry.depdendencies]` from pyproject.toml.
COPY --from=requirements /synapse/requirements.txt /synapse/
RUN --mount=type=cache,target=/root/.cache/pip \
  pip install --prefix="/install" --no-deps --no-warn-script-location -r /synapse/requirements.txt

# Copy over the rest of the synapse source code.
COPY synapse /synapse/synapse/
# ... and what we need to `pip install`.
COPY pyproject.toml README.rst /synapse/

# Repeat of earlier build argument declaration, as this is a new build stage.
ARG TEST_ONLY_IGNORE_POETRY_LOCKFILE

# Install the synapse package itself.
# If we have populated requirements.txt, we don't install any dependencies
# as we should already have those from the previous `pip install` step.
RUN if [ -z "$TEST_ONLY_IGNORE_POETRY_LOCKFILE" ]; then \
    pip install --prefix="/install" --no-deps --no-warn-script-location /synapse[all]; \
  else \
    pip install --prefix="/install" --no-warn-script-location /synapse[all]; \
  fi

###
### Stage 2: Add-ons
###
# Adding:
# 1. Nginx - for reverse proxy support to avoid exposing a mess of ports
# 2. Redis - for internal replication. This is cleaner and faster than an external redis
# 3. Prometheus - to collect the metrics that Synapse exposes if enabled.
# 3a. Redis metrics exporter
# 3b. Nginx metrics exporter
# ?4. DNS caching - Maybe. TODO
# ?5. Grafana - Maybe. External is probably better. TODO
# ?6. Postgres - Maybe. Internal server with external persistent storage db files. TODO
# ?6a. Postgres metrics exporter
# ?7. Coturn - Maybe. Notoriously hard to get it right. Lots of ports to expose. TODO

# A base image with nginx and prometheus which we can copy into the
# target image. For repeated rebuilds, this is much faster than apt installing
# each time.

FROM debian:bullseye-slim AS deps_base
    RUN \
       --mount=type=cache,target=/var/cache/apt,sharing=locked \
       --mount=type=cache,target=/var/lib/apt,sharing=locked \
      apt-get update -qq && \
      DEBIAN_FRONTEND=noninteractive apt-get install -yqq --no-install-recommends \
          nginx-light \
          prometheus \
          && rm -rf /var/lib/apt/lists/*

# Similarly, a base to copy the redis server from.
#
# The redis docker image has fewer dynamic libraries than the debian package,
# which makes it much easier to copy (but we need to make sure we use an image
# based on the same debian version as the synapse image, to make sure we get
# the expected version of libc.

FROM redis:6-bullseye AS redis_base

# The redis exporter found at https://github.com/oliver006/redis_exporter
#
# Uses an alpine container to build the exporter itself with go.

FROM --platform=linux/amd64 golang:1.19-alpine as redis_exporter_builder

WORKDIR /opt/redis_exporter

RUN apk --no-cache add ca-certificates git

RUN git clone https://github.com/oliver006/redis_exporter.git .

# ADD . /go/src/github.com/oliver006/redis_exporter/

ARG SHA1="[no-sha]"
ARG TAG="[no-tag]"
ARG GOARCH="amd64"

RUN BUILD_DATE=$(date +%F-%T) CGO_ENABLED=0 GOOS=linux GOARCH=$GOARCH go build -o /redis_exporter \
    -ldflags  "-s -w -extldflags \"-static\" -X main.BuildVersion=$TAG -X main.BuildCommitSha=$SHA1 -X main.BuildDate=$BUILD_DATE" .

RUN [ "$GOARCH" = "amd64" ]  && /redis_exporter -version || ls -la /redis_exporter

###
### Stage #: runtime
###

FROM docker.io/python:${PYTHON_VERSION}-slim

LABEL org.opencontainers.image.url='https://matrix.org/docs/projects/server/synapse'
LABEL org.opencontainers.image.documentation='https://github.com/realtyem/synapse/blob/master/docker/README.md'
LABEL org.opencontainers.image.source='https://github.com/realtyem/synapse.git'
LABEL org.opencontainers.image.licenses='Apache-2.0'

RUN \
   --mount=type=cache,target=/var/cache/apt,sharing=locked \
   --mount=type=cache,target=/var/lib/apt,sharing=locked \
  apt-get update -qq && apt-get install -yqq \
    curl \
    gosu \
    libjpeg62-turbo \
    libpq5 \
    libwebp6 \
    xmlsec1 \
    libjemalloc2 \
    libssl-dev \
    openssl \
    && rm -rf /var/lib/apt/lists/*

COPY --from=builder /install /usr/local

# Prepare directories. Do it in one layer
RUN mkdir -p /etc/supervisor/conf.d && \
    mkdir /var/log/nginx /var/lib/nginx && \
    chown www-data /var/log/nginx /var/lib/nginx && \
    mkdir -p /etc/prometheus

# Install supervisord with pip instead of apt, to avoid installing a second
# copy of python.
RUN --mount=type=cache,target=/root/.cache/pip \
    pip install supervisor~=4.2

# Copy over redis and nginx
COPY --from=redis_base /usr/local/bin/redis-server /usr/local/bin

COPY --from=deps_base /usr/sbin/nginx /usr/sbin
COPY --from=deps_base /usr/share/nginx /usr/share/nginx
COPY --from=deps_base /usr/lib/nginx /usr/lib/nginx
COPY --from=deps_base /etc/nginx /etc/nginx
RUN rm /etc/nginx/sites-enabled/default

# Copy over Prometheus. Should we bring the website files. It's 10's of MB's
COPY --from=deps_base /usr/bin/prometheus /usr/bin
COPY --from=deps_base /usr/share/prometheus/* /usr/share/prometheus

# Copy in the redis_exporter
COPY --from=redis_exporter_builder /redis_exporter /usr/local/bin/redis_exporter
COPY --from=redis_exporter_builder /etc/ssl/certs /etc/ssl/certs

# Copy Synapse worker, nginx and supervisord configuration template files
# The base start up script, used to generate some config files
# The worker configuration start up script. Will start supervisord.
COPY ./docker/start.py ./docker/configure_workers_and_start.py /

# Various config templates.
COPY ./docker/conf ./docker/conf-workers /conf/

# Copy a script to prefix log lines with the supervisor program name
COPY ./docker/prefix-log /usr/local/bin/
# Copy over prometheus contrib files, rules and such
COPY ./contrib/prometheus/* /etc/prometheus/

# Expose nginx listener port
EXPOSE 8008/tcp
# Expose the prometheus listener port
EXPOSE 9090/tcp

ENTRYPOINT ["/configure_workers_and_start.py"]

# Replace the healthcheck with one which checks *all* the workers. The script
# is generated by configure_workers_and_start.py.
HEALTHCHECK --start-period=5s --interval=15s --timeout=5s \
    CMD /bin/sh /healthcheck.sh
